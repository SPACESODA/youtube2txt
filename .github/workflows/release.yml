name: Build and Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag to publish (e.g. v1.3.9)'
        required: false

permissions:
  contents: write

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.tag || github.ref }}
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - name: Install dependencies
        run: npm ci
      - name: Build and publish release assets
        run: npx electron-builder --publish always
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CSC_IDENTITY_AUTO_DISCOVERY: 'false'
      - name: Log build outputs
        run: node -e "const fs=require('fs');const p='dist';if(!fs.existsSync(p)){console.log('dist/ not found');process.exit(0);}console.log('dist/ outputs:');for(const f of fs.readdirSync(p))console.log('- '+f);"
      - name: Log publish completion
        run: echo "Published assets for ${{ matrix.os }}"
      - name: Cleanup build artifacts
        run: node scripts/cleanup-dist.js

  publish_release:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Publish and rename GitHub release
        uses: actions/github-script@v7
        env:
          RELEASE_TAG: ${{ inputs.tag }}
        with:
          script: |
            const inputTag = process.env.RELEASE_TAG;
            const refTag = process.env.GITHUB_REF_NAME;
            const tag = inputTag || refTag;
            if (context.eventName === 'workflow_dispatch' && !inputTag) {
              core.warning('No tag input provided; skipping release publish/rename.');
              return;
            }
            if (!tag || !tag.startsWith('v')) {
              core.warning(`No tag ref (${tag}); skipping release publish/rename.`);
              return;
            }
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            const maxAttempts = 5;
            let release = null;
            for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
              try {
                const response = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
                release = response.data;
                break;
              } catch (error) {
                const status = error && error.status;
                if (status !== 404 || attempt === maxAttempts) {
                  throw error;
                }
                core.warning(`Release not ready yet (attempt ${attempt}/${maxAttempts}); retrying...`);
                await wait(10000);
              }
            }
            if (!release) {
              core.warning(`Release ${tag} not found after ${maxAttempts} attempts; skipping.`);
              return;
            }
            await github.rest.repos.updateRelease({
              owner,
              repo,
              release_id: release.id,
              draft: false,
              name: tag,
            });
            core.info(`Published release ${tag} and set name to ${tag}.`);
